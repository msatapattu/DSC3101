{
  "hash": "6bc4980d4c4f4cd93a7f6109d11a7bcd",
  "result": {
    "markdown": "---\ntitle: DSC 3091- Advanced Statistics Applications I\nsubtitle: \"Penalized Regression and LARS algorithm\"\nauthor: Dr Jagath Senarathne\ninstitute: Department of Statistics and Computer Science \nformat: \n  revealjs:\n      theme: [beige, custom.scss]\n      slide-number: true\n      chalkboard: \n        theme: whiteboard\n      \neditor: visual\n---\n\n\n# Penalized Regression\n\n-   Use the concept of penalizing or reducing the impact of certain variables in the model.\n\n-   More suitable for large multivariate data sets containing a number of variables superior to the number of samples.\n\n-   Also useful for selecting key variables from a large set of variables.\n\n-   Penalized regression models improve prediction in new data by shrinking the size of coefficients and retaining those with coefficients greater than zero.\n\n# Penalized regression methods\n\n-   Includes a penalty term to reduce (i.e. shrink) the coefficient values towards zero.\n\n-   As such, the variables with minor contribution to the outcome have their coefficients close to zero.\n\n-   Shrinkage methods:\n\n    1.  Ridge Regression\n\n    2.  Lasso Regression\n\n    3.  Elastic net Regression\n\n# Ridge Regression\n\n-   We use ridge regression to tackle the multicollinearity problem.\n\n-   Due to multicollinearity, the model estimates (least square) see a large variance.\n\n-   Ridge regression is a method by which we add a degree of bias to the regression estimates.\n\n-   Ridge regression performs L2 regularization which adds a penalty equivalent to the sum of the squared coefficients and tries to minimize them.\n\n------------------------------------------------------------------------\n\n-   The ridge regression minimizes,\n\n$\\sum(Y_i-\\hat{Y}_i)^2+\\lambda\\sum{\\beta_j^2}$\n\n![](images/paste-4F17340D.png)\n\n------------------------------------------------------------------------\n\n## Build a ridge regression model in r\n\n-   To build the ridge regression in r, we use `glmnet` function from glmnet package in R.\n\n::: callout-note\n## Example\n\nLet's consider the mtcars dataset in R, and fit a ridge regression model to predict the mileage of the car.\n:::\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(glmnet)\nx_var <- data.matrix(mtcars[, c(\"hp\", \"wt\", \"drat\")])\ny_var <- mtcars[, \"mpg\"]\nlambda_seq <- 10^seq(2, -2, by = -.1)\nfit <- glmnet(x_var, y_var, alpha = 0, lambda  = lambda_seq)\nsummary(fit)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n          Length Class     Mode   \na0         41    -none-    numeric\nbeta      123    dgCMatrix S4     \ndf         41    -none-    numeric\ndim         2    -none-    numeric\nlambda     41    -none-    numeric\ndev.ratio  41    -none-    numeric\nnulldev     1    -none-    numeric\nnpasses     1    -none-    numeric\njerr        1    -none-    numeric\noffset      1    -none-    logical\ncall        5    -none-    call   \nnobs        1    -none-    numeric\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Get coefficients of all 100 models\nridge_coef <- coef(fit)\n\n# Display coefficients for 7 models. \nround(ridge_coef[, c(1:3, 38:41)], 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4 x 7 sparse Matrix of class \"dgCMatrix\"\n                s0     s1     s2    s37    s38    s39    s40\n(Intercept) 20.092 20.100 20.112 29.271 29.293 29.313 29.329\nhp          -0.004 -0.004 -0.005 -0.032 -0.032 -0.032 -0.032\nwt          -0.281 -0.344 -0.418 -3.209 -3.212 -3.215 -3.218\ndrat         0.398  0.485  0.587  1.633  1.630  1.627  1.625\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lecture6_files/figure-revealjs/unnamed-chunk-3-1.png){width=960}\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n-   We can also produce a Trace plot to visualize how the coefficient estimates changed as a result of increasing $\\lambda$.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(fit, xvar =\"lambda\")\n```\n\n::: {.cell-output-display}\n![](lecture6_files/figure-revealjs/unnamed-chunk-4-1.png){width=960}\n:::\n:::\n\n\n## Choose an Optimal Value for $\\lambda$\n\n-   Identify the lambda value that produces the lowest mean squared error (MSE) by using k-fold cross-validation.\n\n-   `glmnet` has the function `cv.glmnet()` that performs k-fold cross validation using k = 10 folds.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n#perform k-fold cross-validation to find optimal lambda value\ncv_model <- cv.glmnet(x_var, y_var, alpha = 0)\n\n#find optimal lambda value that minimizes test MSE\nbest_lambda <- cv_model$lambda.min\nbest_lambda\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1.08339\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## Plot of MSE by lambda value\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(cv_model)\n```\n\n::: {.cell-output-display}\n![](lecture6_files/figure-revealjs/unnamed-chunk-6-1.png){width=960}\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## Final model\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfinal_model <- glmnet(x_var, y_var, alpha = 0, lambda = best_lambda)\ncoef(final_model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4 x 1 sparse Matrix of class \"dgCMatrix\"\n                     s0\n(Intercept) 25.49107983\nhp          -0.03051333\nwt          -2.63641838\ndrat         2.10130824\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## R-squared of the model\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny_predicted <- predict(final_model, s = best_lambda, newx = x_var)\n\n#find SST and SSE\nsst <- sum((y_var - mean(y_var))^2)\nsse <- sum((y_predicted - y_var)^2)\n\n#find R-Squared\nrsq <- 1 - sse/sst\nrsq\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8296018\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n-   `lmridge` package can also be used to fit ridge regression models in R.\n\n    ![](images/paste-5F48DD3D.png)\n\n    <https://journal.r-project.org/archive/2018/RJ-2018-060/RJ-2018-060.pdf>\n\n# Lasso regression\n\n-   Lasso stands for Least Absolute Shrinkage and Selection Operator.\n\n-   It shrinks the regression coefficients toward zero by penalizing the regression model with a penalty term called L1-norm.\n\n$\\sum(Y_i-\\hat{Y}_i)^2+\\lambda\\sum{|\\beta_j|}$\n\n------------------------------------------------------------------------\n\n-   One advantage of lasso regression over ridge regression, is that it produces simpler and more interpretable models that incorporate only a reduced set of the predictors.\n\n-   However, neither ridge regression nor the lasso will universally dominate the other.\n\n-   Generally, lasso might perform better in a situation where some of the predictors have large coefficients, and the remaining predictors have very small coefficients.\n\n-   Ridge regression will perform better when the outcome is a function of many predictors, all with coefficients of roughly equal size.\n\n------------------------------------------------------------------------\n\n## Computing lasso regression in R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Find the best lambda using cross-validation\nset.seed(123) \ncvl <- cv.glmnet(x_var, y_var, alpha = 1)\n# Display the best lambda value\ncvl$lambda.min\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1034148\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Fit the final model on the training data\nmodel_lasso <- glmnet(x_var, y_var, alpha = 1, lambda = cvl$lambda.min)\n# Dsiplay regression coefficients\ncoef(model_lasso)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4 x 1 sparse Matrix of class \"dgCMatrix\"\n                     s0\n(Intercept) 29.63708800\nhp          -0.03125498\nwt          -3.21282109\ndrat         1.49439939\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## R-squared of the lasso regression model\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny_predicted <- predict(model_lasso, s = cvl$lambda.min, newx = x_var)\n\n#find SST and SSE\nsst <- sum((y_var - mean(y_var))^2)\nsse <- sum((y_predicted - y_var)^2)\n\n#find R-Squared\nrsq <- 1 - sse/sst\nrsq\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8364553\n```\n:::\n:::\n\n\n# Elastic net regession\n\n-   Elastic Net produces a regression model that is penalized with both the L1-norm and L2-norm.\n\n-   The objective of this method is to effectively shrink coefficients (like in ridge regression) and to set some coefficients to zero (as in LASSO).\n\n-   The elastic net regression can be easily computed using the `caret` workflow, which invokes the `glmnet` package.\n\n-   The caret packages tests a range of possible alpha and lambda values, then selects the best values for lambda and alpha, resulting to a final model that is an elastic net model.\n\n------------------------------------------------------------------------\n\n## How to find alpha and lambda?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(caret)\ndata.new <- data.frame(y_var,x_var)\nset.seed(123)\nmodel_ER <- train(\n  y_var~.,data=data.new, method = \"glmnet\",\n  trControl = trainControl(\"cv\", number = 10),\n  tuneLength = 10\n)\n# Best tuning parameter\nmodel_ER$bestTune\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  alpha   lambda\n6   0.1 0.834975\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n-   Coefficient of the final model:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoef(model_ER$finalModel, model_ER$bestTune$lambda)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n4 x 1 sparse Matrix of class \"dgCMatrix\"\n                     s1\n(Intercept) 26.44660083\nhp          -0.03051303\nwt          -2.74813181\ndrat         1.93555113\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## R-squared of the elastic net regression model\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny_predicted <- predict(model_ER, newx = x_var)\n\n#find SST and SSE\nsst <- sum((y_var - mean(y_var))^2)\nsse <- sum((y_predicted - y_var)^2)\n\n#find R-Squared\nrsq <- 1 - sse/sst\nrsq\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.8312703\n```\n:::\n:::\n\n\n# LARS algorithm\n\n-   Least-angle regression (LARS) is an algorithm for fitting linear regression models to high-dimensional data.\n\n-   It is a model selection method for linear regression.\n\n-   At each step, LARS finds the attribute which is most highly correlated to the target value.\n\n------------------------------------------------------------------------\n\n## Algorithm\n\n1.  Normalize all values to have zero mean and unit variance.\n\n2.  Find a variable that is most highly correlated to the residual. Move the regression line in this direction until we reach another variable that has the same or higher correlation.\n\n3.  When we have two variables that have the same correlation, move the regression line at an angle that is in between (i.e., least angle between the two variables).\n\n4.  Continue this until all of our data is exhausted or until you think the model is big and 'general' enough.\n\n------------------------------------------------------------------------\n\n## Computing LARS model in R\n\n-   Can use the `lars` function from `lars` package in R.\n\n`lars(x, y, type = c(\"lasso\", \"lar\", \"forward.stagewise\", \"stepwise\"), trace = FALSE, normalize = TRUE, intercept = TRUE, Gram, eps = 1e-12, max.steps, use.Gram = TRUE)`\n\n------------------------------------------------------------------------\n\n## Example\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(lars)\nLars_obj <- lars(x_var,y_var,type=\"lar\")\nLars_obj\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlars(x = x_var, y = y_var, type = \"lar\")\nR-squared: 0.837 \nSequence of LAR moves:\n     wt hp drat\nVar   2  1    3\nStep  1  2    3\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(Lars_obj)\n```\n\n::: {.cell-output-display}\n![](lecture6_files/figure-revealjs/unnamed-chunk-16-1.png){width=960}\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](lecture6_files/figure-revealjs/unnamed-chunk-17-1.png){width=960}\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n### Advantages of using LARS:\n\n-   Computationally as fast as forward selection but may sometimes be more accurate.\n\n-   Numerically very efficient when the number of features is much larger than the number of data instances.\n\n-   It can easily be modified to produce solutions for other estimators.\n\n### Disadvantages of using LARS:\n\n-   LARS is highly sensitive to noise and can produce unpredictable results sometimes.\n\n------------------------------------------------------------------------\n\n::: callout-important\n## IN-CLASS ASSIGNMENT\n\nObtain a penalized regression model that best describes the variations in the response variable `medv` from the `Boston` dataset in `MASS` package.\n:::\n\n# Some Useful Links ...\n\n-   <http://www.sthda.com/english/articles/37-model-selection-essentials-in-r/153-penalized-regression-essentials-ridge-lasso-elastic-net/>\n\n-   <https://www.r-bloggers.com/2020/05/simple-guide-to-ridge-regression-in-r/>\n\n-   <https://www.pluralsight.com/guides/linear-lasso-and-ridge-regression-with-r>\n\n-   <https://rpubs.com/beane/n6_1>\n\n-   <https://cran.r-project.org/web/packages/lars/lars.pdf>\n",
    "supporting": [
      "lecture6_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n\r\n      // dispatch for htmlwidgets\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for reveal\r\n    if (window.Reveal) {\r\n      window.Reveal.addEventListener(\"slidechanged\", function(event) {\r\n        fireSlideChanged(event.previousSlide, event.currentSlide);\r\n      });\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}